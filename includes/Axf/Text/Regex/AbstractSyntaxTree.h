/*
 * Copyright (C) 2022 Javier Marrero.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301  USA
 */

/* 
 * File:   AbstractSyntaxTree.h
 * Author: Javier Marrero
 *
 * Created on December 24, 2022, 7:08 PM
 */

#ifndef ABSTRACTSYNTAXTREE_H
#define ABSTRACTSYNTAXTREE_H

// API
#include <Axf/Collections/ArrayList.h>
#include <Axf/Core/Object.h>
#include <Axf/Core/Memory.h>
#include <Axf/Text/Regex/Tokens.h>

namespace axf
{
namespace text
{
namespace regex
{
namespace ast
{

/**
 * Abstract syntax tree node general base class.
 * <p>
 * This class acts as a base class for the annotated parse tree generated by
 * the regular expression pattern compiler. This tree will be then parsed and
 * a nondeterministic finite state automata representing the described regular
 * expression will be created.
 * <p>
 * This class is part of the regular expression package private API and it is
 * not destined to be used by the general public. As such, the rest of the
 * classes within this namespace will probably be undocumented.
 *
 * @author J. Marrero
 */
class AstNode : public core::Object
{

    AXF_CLASS_TYPE(axf::text::regex::ast::AstNode,
                   AXF_TYPE(axf::core::Object))
public:

    /**
     * Enumerates all the possible classes of Abstract Syntax Tree nodes.
     */
    enum Type
    {
        ATOM,
        CHARACTER,
        EXPRESSION,
        FACTOR,
        TERM,
    } ;

    AstNode(Type type);
    ~AstNode();

    /**
     * Returns the type of this node. The type is set up at creation time by
     * the deriving classes.
     *
     * @return
     */
    inline Type getType() const
    {
        return m_type;
    }

    virtual core::string toString() const
    {
        core::string s;
        writeString(0, s);
        return s;
    }

    virtual void writeString(int ident, core::string& buffer) const = 0;

protected:

    Type    m_type;

    static core::string pad(int level);

} ;

class Character : public AstNode
{
public:

    Character(const core::uchar& c);
    ~Character();

    inline const core::uchar& getCharacter() const
    {
        return m_character;
    }

    virtual void writeString(int ident, core::string& buffer) const;

private:

    core::uchar m_character;

} ;

class Atom : public AstNode
{
public:

    Atom();
    ~Atom();

    inline Type peekType() const
    {
        return m_internal->getType();
    }

    inline AstNode* get()
    {
        return m_internal.get();
    }

    inline void set(AstNode* node)
    {
        m_internal = node;
    }

    virtual void writeString(int ident, core::string& buffer) const;

private:

    core::strong_ref<AstNode> m_internal;

} ;

class Factor : public AstNode
{
public:

    static const int UNDEFINED_META = -1;

    Factor();
    ~Factor();

    inline bool hasMetacharacter() const
    {
        return m_metacharacter != UNDEFINED_META;
    }

    inline int getMetacharacter()
    {
        return m_metacharacter;
    }

    inline Atom* getAtom()
    {
        return m_atom.get();
    }

    inline void setAtom(Atom* atom)
    {
        m_atom = atom;
    }

    inline void setMetacharacter(int metacharacter)
    {
        m_metacharacter = metacharacter;
    }

    virtual void writeString(int ident, core::string& buffer) const;

private:

    core::strong_ref<Atom>  m_atom;
    int                     m_metacharacter;
} ;

class Term : public AstNode
{
public:

    Term();
    ~Term();

    inline void setFactor(Factor* factor)
    {
        m_factor = factor;
    }

    inline void addTerm(Term* next)
    {
        m_term = next;
    }

    inline bool hasNext() const
    {
        return m_term.isNull() == false;
    }

    inline Factor* getFactor()
    {
        return m_factor.get();
    }

    inline Term* getNextTerm()
    {
        return static_cast<Term*> (m_term.get());
    }

    virtual void writeString(int ident, core::string& buffer) const;

private:

    core::strong_ref<Factor>    m_factor;
    core::strong_ref<AstNode>   m_term;

} ;

/**
 * An expression is a term, or a term or an expression
 */
class Expression : public AstNode
{
public:

    Expression();
    ~Expression();

    inline void setTerm(Term* term)
    {
        m_lhs = term;
    }

    inline void setRhsExpression(AstNode* expression)
    {
        m_rhs = expression;
    }

    inline Term* getLeftHandSideExpression()
    {
        return m_lhs.get();
    }

    inline bool hasAlternative() const
    {
        return m_rhs.isNull() == false;
    }

    inline Expression* getRightHandSideExpression()
    {
        return static_cast<Expression*> (m_rhs.get());
    }
    
    virtual void writeString(int ident, core::string& buffer) const;

private:

    core::strong_ref<Term>          m_lhs;
    core::strong_ref<AstNode>       m_rhs;

} ;

}
}
}
}

#endif /* ABSTRACTSYNTAXTREE_H */
